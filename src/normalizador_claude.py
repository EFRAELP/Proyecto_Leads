"""
normalizador_claude.py
Interacci√≥n con Claude API para normalizaci√≥n de datos
"""

from anthropic import Anthropic


class NormalizadorClaude:
    """Manejador de interacciones con Claude API"""
    
    def __init__(self, api_key, logger):
        """
        Inicializa el normalizador con Claude
        
        Args:
            api_key: API key de Anthropic
            logger: Instancia de Logger para registrar mensajes
        """
        self.client = Anthropic(api_key=api_key) if api_key else None
        self.logger = logger
        self.tokens_usados = 0
        # ‚≠ê NUEVO: Tracking de uso de web_search
        self.llamadas_con_web_search = 0
        self.llamadas_sin_web_search = 0
        self.llamadas_totales = 0
    
    def normalizar_con_claude(self, texto, tipo):
        """Usa Claude API para normalizar - VERSI√ìN MEJORADA CON PROMPT CONSERVADOR"""
        if not self.client:
            self.logger.log("‚ö†Ô∏è No hay API key")
            return texto
        
        # ‚≠ê PROMPT COMPLETAMENTE REESCRITO - M√ÅS AGRESIVO CON "OTRO"
        prompts = {
            'colegio': f"""Eres un clasificador ESTRICTO de instituciones educativas guatemaltecas.

TEXTO A CLASIFICAR: "{texto}"

üîç CU√ÅNDO USAR WEB_SEARCH:
- Si ves SIGLAS desconocidas (IGA, IPGA, IMB-PC, IEMCOOP, ISEA, CED-IECA, CEPREC, UDEO, CCB, etc.)
- Si el nombre es poco com√∫n y no est√°s 100% seguro
- Si necesitas verificar si una instituci√≥n existe en Guatemala

üìê REGLAS DE CLASIFICACI√ìN:

A) RESPUESTAS INV√ÅLIDAS ‚Üí "Otro":
   ‚ùå "no", "ninguno", "no estudio", "ya me gradu√©", "graduado", "terminado"
   ‚ùå "prueba", "test", "demo", "ejemplo", "aaa", "xxx", "123"
   ‚ùå Carreras: "perito en...", "bachillerato", "magisterio"
   ‚ùå Sin informaci√≥n: "hola", "finalizado", "xd"

B) PATRONES = COLEGIO (NO universidad):
   ‚úÖ Si inicia con: "Liceo", "Instituto", "Colegio", "Escuela", "INED", "INEB", "Centro Educativo"
   ‚úÖ Ejemplo: "Liceo Frater" ‚Üí "Liceo Frater" (colegio, NO universidad)
   ‚úÖ Ejemplo: "Instituto Nacional de Educaci√≥n Diversificada" ‚Üí "Instituto Nacional de Educaci√≥n Diversificada (INED)"

C) UNIVERSIDADES GUATEMALTECAS:
   ‚úÖ USAC, URL, UMG, Galileo, Da Vinci, UVG, Panamericana, Mariano G√°lvez, Rafael Land√≠var
   ‚úÖ ITEC UVG = Universidad del Valle de Guatemala
   ‚úÖ Si dice "Universidad" verifica que exista en Guatemala

D) ERRORES COMUNES A EVITAR:
   ‚ùå "escuela de formaci√≥n secretarial" ‚Üí "Escuela de Formaci√≥n Secretarial" (NO universidad)
   ‚ùå "Liceo comercial entre valles" ‚Üí mantenerlo o investigar (NO es UVG autom√°ticamente)
   ‚ùå "mo" sin contexto ‚Üí "Otro" (no inventes)
   ‚ùå IGA = Instituto Guatemalteco Americano (colegio real, NO "Otro")
   ‚ùå IPGA = Instituto Privado Guatemala Americano (investiga si no est√°s seguro)

E) SIGLAS - USA WEB_SEARCH:
   üîç Si ves siglas y no est√°s 100% seguro del nombre completo, USA web_search
   ‚úÖ Si es colegio relevante conocido en Guatemala, exp√°ndelo
   ‚ùå Si no encuentras informaci√≥n confiable, mant√©n la sigla (NO pongas "Otro")

F) N√öMEROS EN NOMBRES:
   ‚ö†Ô∏è NO CAMBIES n√∫meros: "Escuela No. 5" ‚Üí "Escuela Nacional de Ciencias Comerciales No. 5"
   ‚ùå NO cambies 5 por 3 u otro n√∫mero

G) CU√ÅNDO TENGAS DUDA ‚Üí "Otro":
   Si hay CUALQUIER incertidumbre sobre si es una instituci√≥n real, responde "Otro".
   Mejor clasificar como "Otro" que dar un nombre incorrecto.

üì§ RESPONDE SOLO CON:
- El nombre normalizado limpio
- "Otro" si es respuesta inv√°lida
- NO agregues explicaciones

Nombre normalizado:""",

            'grado': f"""Grado acad√©mico: "{texto}"

REGLAS:
- B√°sicos: 1ro B√°sico, 2do B√°sico, 3ro B√°sico
- Diversificado: 4to Diversificado, 5to Diversificado, 6to Diversificado  
- Bachillerato: 4to Bachillerato, 5to Bachillerato, 6to Bachillerato
- Universitario: "Estudiante Universitario"
- Graduados: "Graduado Diversificado", "Graduado Universitario"
- T√©cnico: "T√©cnico Universitario"

SOLO el grado normalizado, sin explicaciones."""
        }
        
        try:
            self.logger.log(f"ü§ñ Consultando Claude: '{texto}'")
            
            # ‚≠ê AUMENTADO max_tokens para permitir web_search
            response = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=300,  # Aumentado de 150 a 300
                messages=[{
                    "role": "user",
                    "content": prompts.get(tipo, texto)
                }]
            )
            
            # Actualizar contadores
            self.tokens_usados += response.usage.input_tokens + response.usage.output_tokens
            self.llamadas_totales += 1
            
            # ‚≠ê NUEVO: Detectar si us√≥ web_search
            uso_web_search = False
            if hasattr(response, 'content'):
                for block in response.content:
                    if hasattr(block, 'type') and block.type == 'tool_use':
                        if hasattr(block, 'name') and block.name == 'web_search':
                            uso_web_search = True
                            break
            
            if uso_web_search:
                self.llamadas_con_web_search += 1
            else:
                self.llamadas_sin_web_search += 1
            
            # Extraer texto de la respuesta
            normalizado = response.content[0].text.strip()
            
            # ‚≠ê VALIDACI√ìN MEJORADA
            normalizado = self.validar_respuesta_claude(texto, normalizado, tipo)
            
            return normalizado
            
        except Exception as e:
            self.logger.log(f"‚ùå Error Claude: {e}")
            return texto
    
    def validar_respuesta_claude(self, texto_original, normalizado, tipo='colegio'):
        """Valida que Claude no haya respondido con texto de sistema - VERSI√ìN MEJORADA"""
        
        # Validaci√≥n 1: Respuesta muy larga
        if len(normalizado) > 200:
            self.logger.log(f"‚ö†Ô∏è Respuesta muy larga: '{texto_original}' ‚Üí 'Otro'")
            return "Otro"
        
        # Validaci√≥n 2: Frases de sistema
        frases_sistema = [
            'estoy listo para', 'por favor proporciona',
            'entendido', 'necesito m√°s informaci√≥n',
            'no puedo', 'dame m√°s contexto', 'no encontr√©',
            'no tengo informaci√≥n', 'necesito que me proporciones'
        ]
        
        normalizado_lower = normalizado.lower()
        for frase in frases_sistema:
            if frase in normalizado_lower:
                self.logger.log(f"‚ö†Ô∏è Respuesta de sistema: '{texto_original}' ‚Üí 'Otro'")
                return "Otro"
        
        # Validaci√≥n 3: Formato con m√∫ltiples l√≠neas
        if normalizado.count('\n') > 2:
            self.logger.log(f"‚ö†Ô∏è Respuesta con formato: '{texto_original}' ‚Üí 'Otro'")
            return "Otro"
        
        # ‚≠ê NUEVA Validaci√≥n 4: Respuestas de prueba deben ser "Otro"
        if tipo == 'colegio':
            texto_lower = texto_original.lower().strip()
            respuestas_prueba = ['prueba', 'test', 'testing', 'demo', 'ejemplo']
            if texto_lower in respuestas_prueba and normalizado.lower() != "otro":
                self.logger.log(f"‚ö†Ô∏è Respuesta de prueba corregida: '{texto_original}' ‚Üí 'Otro'")
                return "Otro"
        
        # ‚≠ê NUEVA Validaci√≥n 5: Patr√≥n "Liceo/Instituto" no debe convertirse en Universidad
        if tipo == 'colegio':
            texto_lower = texto_original.lower().strip()
            patrones_colegio = ['liceo', 'instituto', 'escuela', 'colegio']
            
            if any(texto_lower.startswith(patron) for patron in patrones_colegio):
                if 'universidad' in normalizado.lower():
                    self.logger.log(f"‚ö†Ô∏è Error: Colegio convertido en Universidad: '{texto_original}' ‚Üí mantener formato colegio")
                    # Mantener el patr√≥n original pero limpiar
                    return texto_original.strip().title()
        
        # ‚≠ê NUEVA Validaci√≥n 6: Siglas sin sentido ‚Üí "Otro"
        if tipo == 'colegio':
            texto_lower = texto_original.lower().strip()
            siglas_sin_sentido = ['mo', 'xd', 'aaa', 'xxx', 'zzz', 'asdf']
            
            if texto_lower in siglas_sin_sentido:
                if normalizado.lower() != "otro" and len(normalizado) > 10:
                    self.logger.log(f"‚ö†Ô∏è Sigla sin sentido: '{texto_original}' ‚Üí 'Otro'")
                    return "Otro"
        
        # ‚≠ê NUEVA Validaci√≥n 7: Verificar que no cambi√≥ n√∫meros en nombres
        import re
        numeros_original = re.findall(r'\d+', texto_original)
        numeros_normalizado = re.findall(r'\d+', normalizado)
        
        if numeros_original and numeros_normalizado:
            if numeros_original != numeros_normalizado:
                self.logger.log(f"‚ö†Ô∏è Advertencia: N√∫meros cambiados de {numeros_original} a {numeros_normalizado}")
                # No forzar cambio, solo advertir
        
        return normalizado
    
    def validar_normalizacion(self, original, propuesta, tipo):
        """Valida normalizaci√≥n con usuario - MANTIENE FUNCIONALIDAD ORIGINAL"""
        print(f"\n{'='*60}")
        print(f"üìù {tipo.upper()}")
        print(f"Original: {original}")
        print(f"Propuesta: {propuesta}")
        print(f"{'='*60}")
        print("\n1. Aceptar propuesta")
        print("2. Ingresar manualmente")
        print("3. Omitir (mantener original)")
        
        while True:
            opcion = input("\nSelecciona (1-3): ").strip()
            
            if opcion == '1':
                return propuesta
            elif opcion == '2':
                manual = input("Ingresa el valor correcto: ").strip()
                if manual:
                    return manual
                print("‚ö†Ô∏è No puede estar vac√≠o")
            elif opcion == '3':
                return original
            else:
                print("‚ö†Ô∏è Opci√≥n inv√°lida. Selecciona 1-3.")
    
    def preguntar_carrera_form(self, form_name, diccionario, formularios_nuevos):
        """Pregunta al usuario a qu√© carrera pertenece un formulario - MANTIENE FUNCIONALIDAD ORIGINAL"""
        print(f"\n{'='*60}")
        print(f"üìù FORMULARIO NO RECONOCIDO")
        print(f"Formulario: {form_name}")
        print(f"{'='*60}")
        print("\n¬øA qu√© carrera pertenece?")
        print("1. Administraci√≥n de Empresas")
        print("2. Ciencia de la Administraci√≥n")
        print("3. International Marketing and Business Analytics")
        print("4. Comunicaci√≥n Estrat√©gica")
        print("5. Maestr√≠as")
        print("6. Sin especificar")
        
        while True:
            respuesta = input("\nSelecciona (1-6): ").strip()
            
            carreras = {
                '1': 'Administraci√≥n de Empresas',
                '2': 'Ciencia de la Administraci√≥n',
                '3': 'International Marketing and Business Analytics',
                '4': 'Comunicaci√≥n Estrat√©gica',
                '5': 'Maestr√≠as',
                '6': 'Sin especificar'
            }
            
            if respuesta in carreras:
                carrera = carreras[respuesta]
                
                if 'formularios' not in diccionario:
                    diccionario['formularios'] = {}
                diccionario['formularios'][form_name.lower()] = carrera
                
                self.logger.log(f"‚úÖ Formulario mapeado: '{form_name}' ‚Üí '{carrera}'")
                formularios_nuevos.append(f"Form: {form_name} ‚Üí {carrera}")
                
                return carrera
            else:
                print("‚ö†Ô∏è Opci√≥n inv√°lida. Selecciona 1-6.")
    
    def get_tokens_usados(self):
        """Retorna el total de tokens usados - FUNCIONALIDAD ORIGINAL"""
        return self.tokens_usados
    
    def get_estadisticas(self):
        """
        Retorna estad√≠sticas detalladas del uso de Claude - NUEVO
        
        Returns:
            dict: Diccionario con m√©tricas de uso
        """
        porcentaje_web = 0
        if self.llamadas_totales > 0:
            porcentaje_web = (self.llamadas_con_web_search / self.llamadas_totales) * 100
        
        return {
            'tokens_totales': self.tokens_usados,
            'llamadas_totales': self.llamadas_totales,
            'llamadas_con_web_search': self.llamadas_con_web_search,
            'llamadas_sin_web_search': self.llamadas_sin_web_search,
            'porcentaje_web_search': round(porcentaje_web, 1)
        }